from sympy import nextprime
from decimal import Decimal, getcontext
import sympy
import math
from Crypto.Util.number import long_to_bytes


def egcd(a, b):
    if a == 0:
        return b, 0, 1
    else:
        g, y, x = egcd(b % a, a)
        return g, x - (b // a) * y, y

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % m

e = 65537
n = 8281850967132278399574272688766937486036646313403007679588335903785669628431708760927341727806006769095252325575815709840401878674105658204057327337750902945521512357960818523078486774689928139816732080923197367563639383252762498921096166065153092144335239373370093976823925031794323976150363874930075228846801224430767428594024165529140949082062667410186456029480046489969338885725614510660737026927443934115006027747874368836800022473917576424175601374800697491622086825964475396316066082109998646438504664272000556702241576240616765962934452557847306066736505798267513078073147161755828577875047115978481485076227911405625234425533967247248864837854031634968764570599279385827285321806293661331225163255461894680337693227417748934924109356565823327149859245521513696171473417470936260563397398387972467438182651142096935931112668743912944902147582538985769095457203775208567489073198557073226907349118348902079942096374377432431441166710584381655348979330535397040250376989291669788189409825278457889980676574146044704329826483808929549888234303934178478274711686806257841293265249466735277673158607466360053037971774844824065612178793324128914371112619033111301900922374201703477207948412866443213080633623441392016518823291181
c = 6407923537926201847312357068295079879508779752068254604904486842729636773279241546432035102141932853761974844472828552921133743850412718722424893044377874567625621282274625365299685502104113862870672461666586814138206797733946319875258776059721304226419810313489197076949529322847815009706727586961448584443159011118432142946962961532154723891985416387650240762711716865116844837968079333914181751979527853152286708153252001832721723040664452442266930832118353632114958540067674924812749763008217133300059446967170825813909142247660230309955433005706793802514554628379255160648976960069078223370104177403453404917998945232459801324103878906593528309460372271638119657797804398399482025063414403804134607772871958848100256643503372624214762343403925077455660522664025602043433142314759978192969519687720668535544914589329155338178120703060384042066182354031274600184116143293639032906542194564776766076911767759167772137229504115598174156646085123675283692418970988032320780636742598466655712520383055569607154074137271584433653335176877094399371749081016317705026349554938167377640856287458145646649292278971980553895419112860061073864077521131958519819285117031990498977039003918710661660868949818362940359852436185282868088342132

getcontext().prec = 616
decimal_number = Decimal(n)
sqrt_result = decimal_number.sqrt()
sqrt_n = int(sqrt_result)

s2 = sqrt_n * sqrt_n
if s2 < n:
    print("s^2 is less then n")
while s2 < n:
    sqrt_n+=1
    s2 = sqrt_n * sqrt_n
 
s = sqrt_n
t = math.isqrt(s2 - n)
while t*t != (s2 - n):
    s += 1
    s2 = s * s
    t = math.isqrt(s2-n)

p = s + t
q = s - t
if sympy.isprime(p) and sympy.isprime(q) and p*q==n:
    print("waalllaaa !! found it")
print("p = ",p)
print("q = ",q)
print(f"p is prime {sympy.isprime(p)}, q is prime {sympy.isprime(q)}")
print(f"p*q=n : {p*q==n}")

phi_n = (p-1) * (q-1)
d = modinv(e, phi_n)
m = pow(c, d, n)
print("message: ", long_to_bytes(m))

##############  Explanation  #####################
"""
If the RSA modulus n = p * q*, where p and q are close, then finding p and q (factorizing n) can be done relatively efficiently. A good approach is to find a value s such that s2 - n is a perfect square. This leads to finding p and q as solutions to a quadratic equation. 

Elaboration:
1. Understanding the problem:
The RSA algorithm relies on the difficulty of factoring the modulus n. When p and q are close, the difference between their square root √n and either p or q is smaller, making factorization easier.

2. Using the fact that p and q are close:
Let s = ( p + q) / 2 and t = ( p - q) / 2. Note that s is close to √n.
Then, n = p * q* = (s + t) * (s - t) = s2 - t2.
If s is close to √n, then t2 = s2 - n and finding t would lead to p = s + t and q = s - t.
Since p and q are close, t will be a relatively small number. This makes finding t by searching near s efficient.

3. Example:
Suppose n = 3233.
√n ≈ 56.87.
Let s = 57.
s2 - n = 572 - 3233 = 3249 - 3233 = 16, which is a perfect square (42).
Thus, t = 4.
p = s + t = 57 + 4 = 61.
q = s - t = 57 - 4 = 53.
Therefore, 3233 = 53 * 61.

"""